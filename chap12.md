# Chap.12 拡張性
拡張性とは、クライアントが開発者の手を借りずに、特定のニーズ用にインテーフェースのふるまいを変更できること。

## 12.1 プラグインによる拡張
- 一般的には、構築時にアプリケーションにリンクするダイナミックライブラリではなく、実行時に認識され、ロードされるダイナミックライブラリ。

- APIプラグインを採用する利点
    - 用途の拡張
    - コミュニティの発展
    - 更新の小容量化(アプリケーション全体を更新する必要がない)
    - 将来性の確保(プラグインによって機能を追加することで、API自体の将来性を確保する)
    - リスクの分散

### 12.1.2 プラグインシステムの設計上の問題点
- プラグインシステムを構築する際に設計すべき所要な機能は
    1. プラグインAPI・・・プラグインを作成するために、ユーザーがコンパイルとリンクを行う対象のAPI。プラグインシステムを追加することで構築する大きなコードベースのコアAPIとは区別する。
    1. プラグインマネージャー・・・全プラグインのライフサイクルを管理(ロード、登録、ロード解除)するコアAPIコード内のオブジェクト（通常はシングルトン）。このオブジェクトはプラグインレジストリとも呼ばれる。

- API用に開発するプラグインアーキテクチャの詳細
    - C/C++
        - C++の仕様では特定のABI(アプリケーションバイナリインターフェイス)定義はない。そのため、コンパイラやバージョンが異なれば、バイナリ互換性のないコードが生成される可能性がある。これに対して、プレーンCのABIは十分定義されているため、プラットフォームやコンパイラの違いを超えて動作する。
    - バージョン管理
        - あるプラグインについて、APIと互換性があるかどうか確認する必要がある
    - 内部メタデータと外部メタデータ
        - 可読性のある名前やバージョン情報といったメタデータは、プラグインコード自体に定義したり、シンプルな外部ファイル形式で指定したりできる。
    - 一般プラグインマネージャと専用プラグインマネージャ
        - プラグインをロードしてプラグイン内のシンボルにアクセスするだけのローレベルでの一般的な手法がある。しかし、この場合はAPI内部の具体的な型の存在がわからない。
        - 最低でもプラグイン内のオブジェクトの型を前方宣言する方法があるが、APIと独立した実装はできなくなる。
        - 妥協案として、APIに実行時の動的型付けシステムを導入する手法がある。
    - セキュリティ
        - ユーザーのプラグインをどこまで信用するか
    - スタティックライブラリとダイナミックライブラリ
        - スタティックライブラリの場合は、同じ名前の関数を定義する２つのプラグインがあってはならない。ダイナミックの場合は同じ名前でも使える。

### 12.1.3 C++でのプラグイン実装
- 抽象基本クラスを使用する
    - 抽象基本クラスの仮想メソッドを実装すると、ABI問題からプラグインを隔離できる。仮想メソッドの呼び出しは、通常クラスのvtableへのインデックスとして表現されるから。(例外もある)インラインにしたメソッドは直接プラグインに組み込まれるため安全だが、インターフェース内のすべてのメソッドは純粋仮想にするべき
- 自由関数にCリンケージを使用する
    - プラグインAPIのすべてのグローバル関数はCリンケージを使ってC++のABI問題を回避する。つまり、extern Cで宣言する。
- STLと例外を回避する
    - STLクラスや例外は異なる実装間ではABI互換性がない場合がある。
- アロケータの混用を避ける
    - プラグインAPIとは異なるメモリアロケータにリンクされる可能性がある。

