# (序章) API開発の必要性
- 新バージョンのリリースではクライアントに必要な機能を提供しながら、クライアントコードには最小限のインパクト(理想を言えばゼロインパクト)で済むようにすることがAPI設計の目標
    - ソフトウェアは新たな要件や機能のリクエスト、バグ修正などで当初予測もしなかった発展を遂げるもの
    - APIへの変更となると、大混乱を引き起こし、クライアントが使用を中止する可能性も

# 本書の特徴
- 高品質なインターフェースの設計手法に焦点を当てる
    - エンジニアにとって必要不可欠なスキル
- 本書の中心はクリーンでモジュール型のC++インターフェースの記述テクニックで、実装の詳細には踏み込まない
- 初期設計から実装、テスト、ドキュメント作成、リリース、バージョン管理、保守、廃止、スクリプト、プラグインAPIなどAPI開発の全域を取り上げる
- ソースコード例は例であり完全に動作することは想定していない。また、ヘッダファイルを囲むプリプロセッサのインクルードガードや、名前空間などは省略することもある。
```c++
#ifndef MY_MODULE_H
#define MY_MODULE_H

// 必要な#includeファイル

namespace spibook {
    // API宣言・・・
}

#endif
```

# 第1章　はじめに
## 1.1 アプリケーションプログラミングインターフェースとは何か
- アプリケーションプログラミングインターフェイス(API)とは、
    - ある問題に対する抽象化を提供し
    - その問題のソリューションを実装するソフトウェアコンポーネントに対し
    - クライアントの操作方法を明確に定義したもの

- 現在の大半のアプリケーションは多くのAPI上に構築されており、こうしたAPI自体がさらに別のAPI上に構築されている

- API開発の目的は、実装の詳細はすべて隠しながら、コンポーネントの機能に対する論理的なインターフェイスを提供すること
    - 例えば、GIF画像のロードAPIは、ファイル名を受け取って2Dのピクセル配列を返す`LoadImage()`メソッドを提供するだけでよい。
    - このシンプルなインターフェイスの下にファイル形式やデータ圧縮の詳細が隠されている

### 1.1.2 C++のAPI
- C++では、ヘッダファイル(.h)にサポートドキュメントファイルを加えたものになる
- APIの実装は、エンドユーザーアプリケーションにリンクできるライブラリファイル
    - スタティックライブラリ・・・Windowsの.libやMac OS X/Linuxの.a
    - ダイナミックライブラリ・・・Windowsの.dllやMac OS X/Linuxの.so
- まとめると、C++のAPIは以下の3つで構成される
    1. ヘッダ: インターフェイスを定義し、そのインターフェイスに対してクライアントコードにコンパイルさせる.hファイルの集合。
        - オープンソースのAPIには、API実装用のソースコード(.cppファイル)も含まれる
    1. ライブラリ: APIを実装するためのスタティックライブラリorダイナミックライブラリのファイル。この機能をクライアントアプリケーションに追加するために、クライアントコードにはこのライブラリファイルにリンクする。
    1. ドキュメント: APIの使用方法に関する概要情報。API内のクラスや関数すべてについて自動生成したドキュメントを含めることが多い。

## 1.2 API設計の特殊性
- インターフェイス上の問題は、関連する実装コードの問題よりも修正にずっと手間がかかるため、最も重要なコードである。
- API開発が他の開発とは異なるキーポイントを以下に示す。
    1. APIは開発者のために設計されたインターフェース。優れたAPIは会社の最大の財産になるが、お粗末なAPIは悪夢のようなサポート地獄を招き、競合する相手にユーザを取られる可能性すらある
    1. 1つのAPIはいくつものアプリケーションで共有できる。アプリケーションコードの問題はそのアプリケーションだけの問題だが、APIのエラーはそのAPI機能を使うすべてのアプリケーションに影響する！
    1. APIに変更を加えるたびに後方互換性を確保する必要がある。インターフェイスに互換性がなくなったら、クライアントのコードがコンパイルできなくなったり、クラッシュしたりする可能性がある。
        - 例えば、標準Cライブラリの`printf()`関数のシグネチャがコンパイラやプラットフォームごとに違うものを使わなくてはいけなくなったら、あの単純はなずの`"Hello World"`が大変なことになってしまう。
        ```c++
        #include <stdio.h>
        #ifdef _WIN32
        #include <windows.h>
        #endif
        #ifdef __cplusplus
        #include <iostream>
        #endif

        int main(int, char *argv[])
        {
        #if __STRICT_ANSI__
            printf("Hello World\n");
        #elif defined(_WIN32)
            PrintWithFormat("Hello World\n");
        #elif defined(__PRINTF_DEPRECATED__)
            printf(stdout, "Hello World\n");
        #elif defined(__PRINTF_VECTOR__)
            const char *lines[2] = {"Hello World", NULL};
            printf(lines);
        #elif defined(__cplusplus)
            std::cout << "Hello World" << std::endl;
        #else
        #error No termal output API found
        #endif
            return 0;
        } 
        ```
        - コンパイラに付属する標準ヘッダファイルを見てみれば、もっとやばい
    1. 後方互換性の条件を満たすためには、変更管理プロセスをしっかりと確立することが不可欠。インターフェイスへの全変更について、許容範囲内か、正当か、後方互換性が保たれているか、1人or複数のシニアエンジニアがチェックする必要がある。
    1. APIの寿命は概して長い。優れたAPI開発には計画立案、設計、バージョン管理、レビューなど、必要なオーバーヘッドが多いため、先行投資が大きくなりがちだが、こうした手順をしっかりと踏めば、クライアントに迷惑をかけずに根本的な変更や改善をソフトウェアに加えることができ、長期的なコストは大幅に削減できる
    1. APIを書くときには優れたドキュメントの作成が重要。
    1. 自動テストの必要性も極めて重要。APIの実装に大きな変更を加えた時点で、網羅的な回帰テストを行って目的のAPI動作が変わらないことを検証しておけば、クライアントのプログラムを壊さない確証が持てるはず
- 通常、エンジニアは試行錯誤してAPI作成のスキルを学ぶしかなく、API設計の原則とテクニックはエンジニアに教えてられていないのが実態
- この状況を打開するのが本書!!!

## 1.3 APIの必要性
### 1.3.1 コードの堅牢性
- APIの構築にリソースを笹いだ方が良い理由
    1. 実装を隠す。モジュールの実装の詳細を隠せば、将来ユーザーを混乱させずに柔軟に実装を変更できる。これを怠ると
        - 自分のコードのアップデートに制約をかける
        - 新バージョンのライブラリを採用するために、ユーザーにコードの書き換えを強制させる
    1. 寿命が長くなる。実装の詳細を開示したシステムは、時間が経つにつれスパゲティコードになる傾向がある。
    1. モジュール化の促進。
    1. コードの重複を削除。APIの大半は重複コードが発見されてから作成されたもの。
    1. ハードコート(https://wa3.i-3-i.info/word12866.html)された値を撃退。ハードコートした値が全コードベースにコピーされているプログラムがよくある。例えば、データがログファイルに記載されるたびに`myprogram.log`というファイル名を使っている。APIを使えば、この定数値をコードベース全体に複製せずにこの情報にアクセスできる。例えば`GetLogFilename()`というAPI呼び出し。
    1. 実装の変更が容易に。実装の詳細を変更するのにAPIに依存するコードに影響を与えることはなくなる。例えば、ファイルの解析ルーチンで、独自の`char*`バッファを割り当てたり解放したり再割り当てしたりせずに、`std::string`コンテナを使用することができる。
    1. 最適化が容易に。クライアントのコードを変更せずにAPIの性能を最適化できる。

### 1.3.2 コードの再利用
- ソフトウェア開発は、アプリケーションのビルディングブロックを形成する個別のコンポーネントを使ってモジュール化され、その間のやり取りは公開したAPIで行うようになっている。この手法の利点は、各ソフトウェアコンポーネントの詳細を知る必要がないこと。すでに確立したものをやり直すことなく、コアビジネスのロジックに集中できる。
- コードの再利用を行う上で障害となるのは、当初の予定よりもインターフェイスをもっと一般化しなくてはいけないこと。クライアントによっては追加の要件もある。コードの再利用を効果的にするためには、クライアントの要件を深く理解し、クライアント全体としての要件と、自分の要件を統合したシステムを設計すること

### 1.3.3 並行開発
- 複数の開発者が互いに依存するコードを並行して開発している場合、優れたAPI設計のテクニックによって、互いに楽できるようになる。
- 例) 文字列の暗号化アルゴリズムの開発
    - 他の開発者が構成ファイルにデータを書きだすのにこのアルゴリズムを使うとする。
    - 自分の暗号アルゴリズムの開発が終わるまで相手を待たせるのではなく、時間を有効に使うためには、まず二人で適切なAPIについて合意しておく。
    ```c++
    #include <string>
    class StringEncryptor
    {
    public:
        // Encypt()とDecrypt()呼び出しに使うキーを設定
        void SetKey(const std::string &key);

        // 現在のキーに基づいた入力文字列の暗号化
        std::string Excypt(const std::string &str) const;

        // 現在のキーを使って文字列の暗号解除
        // Encrypt()が返した文字列にDecrypt()を呼びだすと、
        // 同じキーに対するオリジナル文字列が返される。
        std::string Decrypt(const std::string &str) const;
    };
    ```
    - つぎに、これらの関数にシンプルな実装を提供して、少なくともモジュールをコンパイル・リンクできるようにする。例えば、関連する.cppファイルは以下のようになる
    ```c++
    void StringEncryptor::SetKey(const std::string &key)
    {
    }

    std::string StringEncryptor::Encrypt(const std::stting &str)
    {
        return str;
    }

    std::string StringEncyptor::Decrypt(const std::string &str)
    {
        return str;
    }
    ```
    - このAPIを使えば、同僚はAPIの開発を待たずに開発ができる。
- 現実には、コードを書くまでは予測できなかったインターフェースの問題にぶちあたるかもしれないが、このAPIで何度か試行錯誤すれば解決策が見つかるはず。全体として、作業の滞りを最小限にできているはず。
- この手法を全社レベルで行えば、一つのプロジェクトに対して複数のチームが独立に開発を進めることができる。自分たちの成果はAPIに隠されており、ほかのチームがどのように使うかはほとんど知る必要はない。これは効率的なリソースの活用であり、重複するコミュニケーションもなくなるので、会社全体としても大きなコスト削減につながる。

## 1.4 APIを使用すべきでない場合